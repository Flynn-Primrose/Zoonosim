import numpy as np
import sciris as sc
from .. import version as znv
from . import defaults
from .. import base as znb
from . import config as cfg
from . import sampling as znsamp
from . import data_distributions as zndata
from . import households as znhh
from . import schools as znsch
from . import workplaces as znwp
from . import contact_networks as zncnx
from . import people as spp
from . import custom as znc

# __all__ = ['Pop', 'make_population', 'generate_synthetic_population']

class BehaviourModel(sc.prettyobj):

    def __init__(self,
                 pars=None
                 ):
        '''
        Make a full population network including both people (ages, sexes) and
        contacts. By default uses Seattle, Washington data. Note about the
        household methods available: 'infer_ages' and 'fixed_ages'.

        If using 'infer_ages', then the ages of individuals in the population
        are generated by first placing individuals into households using the age
        of the head of households or reference individuals (always an adult),
        household age mixing patterns, household sizes, and the age distribution
        from data (census or other sources).

        If using 'fixed_ages', then individuals are pre-assigned ages according
        to the age distribution and placed into households  using the age of the
        head of households or reference individuals, household age mixing
        patterns, and household sizes.

        Args:
            n (int)                                 : The number of people to create.
            max_contacts (dict)                     : A dictionary for maximum number of contacts per layer: keys must be "W" (work).
            school_pars (dict)                      : if supplied, replace default school parameters
            with_industry_code (bool)               : If True, assign industry codes for workplaces, currently only possible for cached files of populations in the US.
            with_facilities (bool)                  : If True, create long term care facilities, currently only available for locations in the US.
            use_default (bool)                      : If True, use default data from settings.location, settings.state, settings.country.
            use_two_group_reduction (bool)          : If True, create long term care facilities with reduced contacts across both groups.
            with_school_types (bool)                : If True, creates explicit school types.
            school_mixing_type (str or dict)        : The mixing type for schools, 'random', 'age_clustered', or 'age_and_class_clustered' if string, and a dictionary of these by school type otherwise.
            average_class_size (float)              : The average classroom size.
            inter_grade_mixing (float)              : The average fraction of edges rewired to create edges between grades in the same school when school_mixing_type is 'age_clustered'
            average_student_teacher_ratio (float)   : The average number of students per teacher.
            average_teacher_teacher_degree (float)  : The average number of contacts per teacher with other teachers.
            teacher_age_min (int)                   : The minimum age for teachers.
            teacher_age_max (int)                   : The maximum age for teachers.
            with_non_teaching_staff (bool)          : If True, includes non teaching staff.
            average_student_all_staff_ratio (float) : The average number of students per staff members at school (including both teachers and non teachers).
            average_additional_staff_degree (float) : The average number of contacts per additional non teaching staff in schools.
            staff_age_min (int)                     : The minimum age for non teaching staff.
            staff_age_max (int)                     : The maximum age for non teaching staff.
            com_contacts: average # contacts in the community. 
            com_dispersion: if none, com_contacts is poisson, else negative binomial. Low dispersion = high spread. 
            rand_seed (int)                         : Start point random sequence is generated from.
            country_location (string)               : name of the country the location is in
            state_location (string)                 : name of the state the location is in
            location (string)                       : name of the location
            sheet_name (string)                     : sheet name where data is located
            household_method (string)               : name of household generation method used; for details see above.
            smooth_ages (bool)                      : If True, use smoothed out age distribution.
            window_length (int)                     : length of window over which to average or smooth out age distribution
            do_make (bool)                          : whether to make the population
            base_uid: the first UID to assign. Ex: if base_uid = 20k, n = 10k, the agents will be numbered 20-30k. 

        Returns:
            network (dict): A dictionary of the full population with ages, connections, and other attributes.
        '''
        
        default_pars = znc.make_pars() # returns a sciris object dict. 
        pars = znc.update_pars(default_pars, pars)
        self.input_pars = pars

        # General parameters
        if pars.n is None:
            pars.n = defaults.default_pop_size

        elif pars.n < defaults.default_pop_size:
            print(f"Population size is less than the default population size of {defaults.default_pop_size}.")
            #TODO: Figure out how to handel warnings

        # Assign all the variables
        self.loc_pars           = sc.objdict()
        self.school_pars        = sc.objdict()
        self.com_pars           = sc.objdict()

        self.n                  = int(pars.n)
        self.max_contacts       = sc.mergedicts({'W': 20}, pars.max_contacts)
        self.rand_seed          = pars.rand_seed
        self.country_location   = pars.country_location
        self.state_location     = pars.state_location
        self.location           = pars.location
        self.sheet_name         = pars.sheet_name
        self.use_default        = pars.use_default

        # Age distribution parameters
        self.smooth_ages                                 = pars.smooth_ages
        self.window_length                               = pars.window_length

        # Household parameters
        self.household_method                            = pars.household_method

        # School parameters
        self.school_pars.with_school_types               = pars.with_school_types
        self.school_pars.school_mixing_type              = pars.school_mixing_type
        self.school_pars.average_class_size              = pars.average_class_size
        self.school_pars.inter_grade_mixing              = pars.inter_grade_mixing
        self.school_pars.average_student_teacher_ratio   = pars.average_student_teacher_ratio
        self.school_pars.average_teacher_teacher_degree  = pars.average_teacher_teacher_degree
        self.school_pars.teacher_age_min                 = pars.teacher_age_min
        self.school_pars.teacher_age_max                 = pars.teacher_age_max
        self.school_pars.with_non_teaching_staff         = pars.with_non_teaching_staff
        self.school_pars.average_student_all_staff_ratio = pars.average_student_all_staff_ratio
        self.school_pars.average_additional_staff_degree = pars.average_additional_staff_degree
        self.school_pars.staff_age_min                   = pars.staff_age_min
        self.school_pars.staff_age_max                   = pars.staff_age_max


        # Community parameters
        self.com_pars.com_dispersion                     = pars.com_dispersion
        self.com_pars.com_contacts                       = pars.com_contacts
        # If any parameters are supplied as a dict to override defaults, merge them in now
        self.school_pars = sc.objdict(sc.mergedicts(self.school_pars, pars.school_pars))

        # what are the layers generated?

        self.layers = ['H', 'S', 'W', 'F']
        self.layer_mappings = dict(H='Households', S='Schools', W='Workplaces', F='Farms')

        # Handle the seed
        if self.rand_seed is not None:
            znsamp.set_seed(self.rand_seed)

        # Handle data
        if self.country_location is None:
            self.country_location = defaults.settings.country_location
            self.state_location   = defaults.settings.state_location
            self.location         = defaults.settings.location
        else:
            print(f"========== setting country location = {pars.country_location}")
            cfg.set_location_defaults(pars.country_location)

        self.max_age = defaults.settings.max_age

        # if country is specified, and state is not, we are doing a country population
        if self.state_location is None:
            self.location = None

        # if sheet name is not specified, use the default
        if self.sheet_name is None:
            self.sheet_name = defaults.settings.sheet_name
        self.datadir = defaults.settings.datadir  # Assume this has been reset...

        # Location parameters
        self.loc_pars.location         = self.location
        self.loc_pars.state_location   = self.state_location
        self.loc_pars.country_location = self.country_location
        self.loc_pars.datadir          = self.datadir
        self.loc_pars.use_default      = self.use_default

        # Used for intermediate computation.
        self.structs = None # structural information
        self.popdict = None # contact information per persion
        self.pars = None # parameters loaded in load_parameters(). Includes sim input params (n, etc) and contact matricies. 

        if pars.as_region == False: # Generate the population separately if doing multi-region simulation, 
            # i.e. via regional_behaviour_model.py
            self.generate() # updates self.popdict

            # Add summaries post hoc  --- TBD: summaries during generation
            self.compute_information()  # compute full information
            self.compute_summary()  # then compute condensed summary

        return

    ############ SOME CONTACT WRAPPER FUNCTIONS ##########

    def init_contact_structure(self):
        sexes_list = np.random.randint(2, size=len(self.structs.age_by_uid))

        sexes = dict()
        i = 0
        for uid in self.structs.age_by_uid:
            sexes[uid] = sexes_list[i]
            i += 1
        
        self.popdict = zncnx.init_popdict_skele(self.structs, sexes=sexes, init_incomes_and_watches = self.input_pars.init_incomes_and_watches)

    def make_home_contacts(self):
        self.popdict = zncnx.make_home_contacts(self, self.structs, self.pars, self.popdict)
    
    def make_school_contacts(self, popdict=None):
        if popdict == None:
            popdict = self.popdict
        popdict = zncnx.make_school_contacts(self, self.structs, self.pars, popdict) # Note: this updates popdict at the source.

    def make_work_contacts(self, popdict=None):
        if popdict == None:
            popdict = self.popdict
        popdict = zncnx.make_work_contacts(self, self.structs, self.pars, popdict)

    def make_comm_contacts(self):
        self.popdict = zncnx.make_community_contacts(self, self.structs, self.pars, self.popdict)

    def make_all_contacts(self):
        self.init_contact_structure()
        self.make_home_contacts()
        self.make_school_contacts()
        self.make_work_contacts()
        self.make_comm_contacts()

    ############################
    def load_pars_and_data(self):
        """
        Loads all census data, contact data, etc. 
        """

        pars = sc.objdict()

        # General parameters
        pars.datadir                         = self.datadir
        pars.location                        = self.location
        pars.state_location                  = self.state_location
        pars.country_location                = self.country_location
        pars.n                               = self.n
        pars.sheet_name                      = self.sheet_name
        pars.max_contacts                    = self.max_contacts
        pars.use_default                     = self.use_default
        pars.loc_pars                        = self.loc_pars

        # Age distribution parameters
        pars.smooth_ages                     = self.smooth_ages
        pars.window_length                   = self.window_length

        # Household parameters
        pars.household_method                = self.household_method

        # LTCF parameters
        pars.use_two_group_reduction         = self.ltcf_pars.use_two_group_reduction
        pars.average_LTCF_degree             = self.ltcf_pars.average_LTCF_degree
        pars.with_facilities                 = self.ltcf_pars.with_facilities
        pars.ltcf_staff_age_min              = self.ltcf_pars.ltcf_staff_age_min
        pars.ltcf_staff_age_max              = self.ltcf_pars.ltcf_staff_age_max

        # School parameters
        pars.with_school_types               = self.school_pars.with_school_types
        pars.school_mixing_type              = self.school_pars.school_mixing_type
        pars.average_class_size              = self.school_pars.average_class_size
        pars.inter_grade_mixing              = self.school_pars.inter_grade_mixing
        pars.average_student_teacher_ratio   = self.school_pars.average_student_teacher_ratio
        pars.average_teacher_teacher_degree  = self.school_pars.average_teacher_teacher_degree
        pars.teacher_age_min                 = self.school_pars.teacher_age_min
        pars.teacher_age_max                 = self.school_pars.teacher_age_max
        pars.with_non_teaching_staff         = self.school_pars.with_non_teaching_staff
        pars.average_student_all_staff_ratio = self.school_pars.average_student_all_staff_ratio
        pars.average_additional_staff_degree = self.school_pars.average_additional_staff_degree
        pars.staff_age_min                   = self.school_pars.staff_age_min
        pars.staff_age_max                   = self.school_pars.staff_age_max

        # Community parameters
        pars.com_dispersion                  = self.com_pars.com_dispersion
        pars.com_contacts                    = self.com_pars.com_contacts

        # Load and store the expected age distribution of the population
        pars.age_bracket_dist = zndata.read_age_bracket_distr(**pars.loc_pars)  # age distribution defined by bins or age brackets
        pars.expected_age_dist = zndata.get_smoothed_single_year_age_distr(**pars.loc_pars, window_length=self.window_length)
        self.expected_age_dist = pars.expected_age_dist
        pars.expected_age_dist_values = [pars.expected_age_dist[a] for a in pars.expected_age_dist]
        self.expected_age_dist_values = pars.expected_age_dist_values

        # Load and store the age brackets
        pars.age_brackets = zndata.get_census_age_brackets(**pars.loc_pars)
        self.age_brackets = pars.age_brackets
        # mapping
        pars.age_by_brackets = znb.get_age_by_brackets(pars.age_brackets)
        self.age_by_brackets = pars.age_by_brackets

        # Load the contact matrix
        pars.contact_matrices = zndata.get_contact_matrices(pars.datadir, sheet_name=pars.sheet_name)
        # Store expected contact matrices
        self.contact_matrices = pars.contact_matrices

        # Load age brackets, and mapping dictionary that matches contact matrices
        contact_matrix_shape = pars.contact_matrices[list(pars.contact_matrices.keys())[0]].shape
        contact_matrix_row = contact_matrix_shape[0]

        pars.cm_age_brackets = zndata.get_census_age_brackets(**pars.loc_pars, nbrackets=contact_matrix_row)
        self.cm_age_brackets = pars.cm_age_brackets
        pars.cm_age_by_brackets = znb.get_age_by_brackets(pars.cm_age_brackets)
        self.cm_age_by_brackets = pars.cm_age_by_brackets
        
        if self.input_pars.init_incomes_and_watches:
            # Load the age-income table. 
            age_income_raw = zndata.get_age_income_dist(**pars.loc_pars)

            # Process it. (Increase the resolution). ai stands for age-income table. 
            pars.age_income_dist, pars.ai_age_bracs, pars.ai_inc_bracs = zndata.process_age_income_dist(age_income_raw, pars.location, pars.state_location, pars.country_location)

            # Load data for distributing smartwatches. params_com_mixing
            pars.sw_params = zndata.get_sw_params(**pars.loc_pars, dist_sw_probabilstically=self.input_pars.dist_sw_probabilstically)

        self.pars = pars

    def generate_households(self, pars, 
        n_nonltcf, ltcf_adjusted_age_dist, ages_left_to_assign, facilities):

        """
        TODO: What's with the facilities?
        """
        # Generate households
        household_size_dist = zndata.get_household_size_distr(**pars.loc_pars)
        hh_sizes = znhh.generate_household_size_count_from_fixed_pop_size(n_nonltcf, household_size_dist)
        hha_brackets = zndata.get_head_age_brackets(**pars.loc_pars)
        hha_by_size = zndata.get_head_age_by_size_distr(**pars.loc_pars)

        if pars.household_method == 'fixed_ages':

            homes_dic, homes = znhh.generate_all_households_fixed_ages(n_nonltcf, hh_sizes, hha_by_size, hha_brackets, pars.cm_age_brackets, pars.cm_age_by_brackets, pars.contact_matrices, ages_left_to_assign)

        else:
            print("Using infer_ages method for households.")
            homes_dic, homes = znhh.generate_all_households_infer_ages(pars.n, n_nonltcf, hh_sizes, hha_by_size, hha_brackets, pars.cm_age_brackets, pars.cm_age_by_brackets, pars.contact_matrices, ltcf_adjusted_age_dist, ages_left_to_assign)

        # Handle homes and facilities
        homes = facilities + homes
        homes_by_uids, age_by_uid = znhh.assign_uids_by_homes(homes, self.input_pars["base_uid"])  # include facilities to assign ids
        # age_by_uid_arr = np.array([age_by_uid[i] for i in range(self.n)], dtype=int)
        self.age_by_uid = age_by_uid

        facilities_by_uid_lists = homes_by_uids[0:len(facilities)]

        return age_by_uid, homes_by_uids, facilities_by_uid_lists, homes

    def get_valid_workers(self, pars, age_by_uid, student_uid_lists, facilities_by_uid_lists):
        # Get employment rates
        employment_rates = zndata.get_employment_rates(**pars.loc_pars)

        # Find people who can be workers (removing everyone who is currently a student)
        uids_by_age = znb.get_ids_by_age(age_by_uid)  # Make a dictionary listing out uids of people by their age
        potential_worker_uids, potential_worker_uids_by_age, potential_worker_ages_left_count = znwp.get_uids_potential_workers(student_uid_lists,
                                                                                                                               employment_rates,
                                                                                                                               age_by_uid)
        workers_by_age_to_assign_count = znwp.get_workers_by_age_to_assign(employment_rates, potential_worker_ages_left_count, uids_by_age)

        return employment_rates, workers_by_age_to_assign_count, potential_worker_uids, potential_worker_uids_by_age, potential_worker_ages_left_count

    def generate_schools(self, pars, n_nonltcf, age_by_uid, homes_by_uids):

        # Generate school sizes
        school_sizes_dist_by_brackets = zndata.get_school_size_distr_by_brackets(**pars.loc_pars)  # without school type
        school_size_brackets = zndata.get_school_size_brackets(**pars.loc_pars)  # for right now the size distribution for all school types will use the same brackets or bins

        # Figure out who's going to school as a student with enrollment rates (gets called inside sp.get_uids_in_school)
        uids_in_school, uids_in_school_by_age, ages_in_school_count = znsch.get_uids_in_school(pars.datadir, n_nonltcf, pars.location, 
                pars.state_location, pars.country_location, age_by_uid, homes_by_uids, use_default=pars.use_default)  # this will call in school enrollment rates

        if pars.with_school_types:
            school_size_distr_by_type = zndata.get_school_size_distr_by_type(**pars.loc_pars)

            school_type_age_ranges = zndata.get_school_type_age_ranges(**pars.loc_pars)

            school_types_distr_by_age = znsch.get_school_types_distr_by_age(school_type_age_ranges)
            school_type_by_age = znsch.get_school_types_by_age_single(school_types_distr_by_age)

            student_age_lists, student_uid_lists, school_types = znsch.send_students_to_school_with_school_types(school_size_distr_by_type,
                                                                                                                 school_size_brackets,
                                                                                                                 uids_in_school,
                                                                                                                 uids_in_school_by_age,
                                                                                                                 ages_in_school_count,
                                                                                                                 school_types_distr_by_age,
                                                                                                                 school_type_age_ranges)

        else:
            # Get school sizes
            school_sizes = znsch.generate_school_sizes(school_sizes_dist_by_brackets, school_size_brackets, uids_in_school)

            # Assign students to school using contact matrix method - generic schools
            student_age_lists, student_uid_lists, school_types = znsch.send_students_to_school(school_sizes,
                                                                                               uids_in_school,
                                                                                               uids_in_school_by_age,
                                                                                               ages_in_school_count,
                                                                                               pars.cm_age_brackets,
                                                                                               pars.cm_age_by_brackets,
                                                                                               pars.contact_matrices)

            school_type_by_age = None
        return student_uid_lists, student_age_lists, school_type_by_age, school_types

    def distribute_workers(self, pars, student_age_lists, student_uid_lists, employment_rates, 
        workers_by_age_to_assign_count, potential_worker_uids, potential_worker_uids_by_age, potential_worker_ages_left_count, facilities, facilities_by_uid_lists, age_by_uid):
        
        # DEBUG
        # print("Beginning Workers: {}".format(len(potential_worker_uids)))
        # Assign teachers and update school lists
        teacher_age_lists, teacher_uid_lists, potential_worker_uids, potential_worker_uids_by_age, workers_by_age_to_assign_count = znsch.assign_teachers_to_schools(student_age_lists,
                                                                                                                                                                     student_uid_lists,
                                                                                                                                                                     employment_rates,
                                                                                                                                                                     workers_by_age_to_assign_count,
                                                                                                                                                                     potential_worker_uids,
                                                                                                                                                                     potential_worker_uids_by_age,
                                                                                                                                                                     potential_worker_ages_left_count,
                                                                                                                                                                     average_student_teacher_ratio=pars.average_student_teacher_ratio,
                                                                                                                                                                     teacher_age_min=pars.teacher_age_min,
                                                                                                                                                                     teacher_age_max=pars.teacher_age_max)
        # Assign non teaching staff and update who's available to work at other places
        non_teaching_staff_uid_lists, potential_worker_uids, potential_worker_uids_by_age, workers_by_age_to_assign_count = znsch.assign_additional_staff_to_schools(student_uid_lists,
                                                                                                                                                                     teacher_uid_lists,
                                                                                                                                                                     workers_by_age_to_assign_count,
                                                                                                                                                                     potential_worker_uids,
                                                                                                                                                                     potential_worker_uids_by_age,
                                                                                                                                                                     potential_worker_ages_left_count,
                                                                                                                                                                     average_student_teacher_ratio=pars.average_student_teacher_ratio,
                                                                                                                                                                     average_student_all_staff_ratio=pars.average_student_all_staff_ratio,
                                                                                                                                                                     staff_age_min=pars.staff_age_min,
                                                                                                                                                                     staff_age_max=pars.staff_age_max,
                                                                                                                                                                     with_non_teaching_staff=pars.with_non_teaching_staff)

        # Generate non-school workplace sizes needed to send everyone to work
        workplace_size_brackets = zndata.get_workplace_size_brackets(**pars.loc_pars)
        workplace_size_distr_by_brackets = zndata.get_workplace_size_distr_by_brackets(**pars.loc_pars)
        workplace_sizes = znwp.generate_workplace_sizes(workplace_size_distr_by_brackets, workplace_size_brackets, workers_by_age_to_assign_count)

        # Assign all workers who are not staff at schools to workplaces
        workplace_age_lists, workplace_uid_lists, potential_worker_uids, potential_worker_uids_by_age, workers_by_age_to_assign_count = znwp.assign_rest_of_workers(workplace_sizes,
                                                                                                                                                                   potential_worker_uids,
                                                                                                                                                                   potential_worker_uids_by_age,
                                                                                                                                                                   workers_by_age_to_assign_count,
                                                                                                                                                                   age_by_uid,
                                                                                                                                                                   pars.cm_age_brackets,
                                                                                                                                                                   pars.cm_age_by_brackets,
                                                                                                                                                                   pars.contact_matrices)

        # DEBUG
        # print("REMAINING WORKERS: {}".format(len(potential_worker_uids)))
        return teacher_uid_lists, non_teaching_staff_uid_lists, workplace_uid_lists

    def consolidate_structures(self, structs):

        """
        For each structural layer, creates a dictionary of those structures. Ex: schools: {1: {students: ...}}
        The workhorse is set_layer_classes(). 
        """

        # temporarily store some information
        self.homes_by_uids = structs.homes_by_uids
        self.workplace_uid_lists = structs.workplace_uid_lists
        self.student_uid_lists = structs.student_uid_lists
        self.teacher_uid_lists = structs.teacher_uid_lists
        self.non_teaching_staff_uid_lists = structs.non_teaching_staff_uid_lists
        self.school_types = structs.school_types
        self.school_mixing_types = [self.schools_in_groups[ns]['school_mixing_type'] for ns in range(len(self.schools_in_groups))]

        self.set_layer_classes()
        self.clean_up_layer_info()

    def get_school_mixing_types(self, school_mixing_type, school_type_by_age):
        """
        Returns dictionary of the school mixing types. Key is the school id. 
        """
        # what are the school types by age
        school_type_by_age = sc.mergedicts(zndata.get_default_school_types_by_age_single(), school_type_by_age)
        school_types = list(set(school_type_by_age.values()))  # get the location specific school types whatever they may be
        # check school mixing type
        if isinstance(school_mixing_type, str):
            school_mixing_type_dic = dict.fromkeys(school_types, school_mixing_type) # The bottom line school mixing types. 
        elif isinstance(school_mixing_type, dict):
            school_mixing_type_dic = sc.dcp(school_mixing_type)
            school_mixing_type_dic = sc.mergedicts(dict.fromkeys(school_types, 'random'), school_mixing_type_dic)  # if the dictionary given doesn't specify the mixing type for an expected school type, set the mixing type for that school type to random by default
        return school_mixing_type_dic

    def distribute_workers_after_make_structures(self):
        """
        MUST BE RUN AFTER make_structures(distribute_workers=False). 
        """
        # Distribute them to your layers. Staff the LTCF's and schools, divvy the rest into workplaces.
        teacher_uid_lists, non_teaching_staff_uid_lists, workplace_uid_lists, facilities_staff_uid_lists = self.distribute_workers(self.pars, self.structs.student_age_lists, self.structs.student_uid_lists, self.work_structs.employment_rates, self.work_structs.workers_by_age_to_assign_count, 
            self.work_structs.potential_worker_uids, self.work_structs.potential_worker_uids_by_age, self.work_structs.potential_worker_ages_left_count, self.structs.facilities, self.structs.facilities_uid_lists, self.structs.age_by_uid)

        self.structs.teacher_uid_lists = teacher_uid_lists
        self.structs.non_teaching_staff_uid_lists = non_teaching_staff_uid_lists
        self.structs.workplace_uid_lists = workplace_uid_lists
        self.structs.facilities_staff_uid_lists = facilities_staff_uid_lists

    def make_structures(self, distribute_workers=True):
        pars = self.pars

        # Generate an age count for the population --- this will get passed around to methods generating the different layers where people live: long term care facilities, households, agricultural living quarters, other group living arrangements
        age_count = znhh.generate_age_count_multinomial(pars.n, pars.expected_age_dist_values)

        # Ages left to assign to a residence
        ages_left_to_assign = sc.dcp(age_count)


        # Generate Homes and place people into them. 
        age_by_uid, homes_by_uids, facilities_by_uid_lists, homes = self.generate_households(pars, ages_left_to_assign)
        
        if self.input_pars.init_incomes_and_watches:
            # Allocate incomes to the households.
            fam_income_by_uid = znc.allocate_household_incomes(pars, age_by_uid, homes_by_uids, homes)

        # Generate Schools and put students into them. (Put teachers in later)
        student_uid_lists, student_age_lists, school_type_by_age, school_types = self.generate_schools(pars, age_by_uid, homes_by_uids)

        # Get pool of workers
        employment_rates, workers_by_age_to_assign_count, potential_worker_uids, potential_worker_uids_by_age, potential_worker_ages_left_count = self.get_valid_workers(pars, age_by_uid, student_uid_lists, facilities_by_uid_lists)

        if distribute_workers:
            # Distribute them to your layers. Staff the LTCF's and schools, divvy the rest into workplaces.
            teacher_uid_lists, non_teaching_staff_uid_lists, workplace_uid_lists, facilities_staff_uid_lists = self.distribute_workers(pars, student_age_lists, student_uid_lists, employment_rates, workers_by_age_to_assign_count, 
                potential_worker_uids, potential_worker_uids_by_age, potential_worker_ages_left_count, facilities_by_uid_lists, age_by_uid)
        else:
            # Place the valid worker data structures into internal state. 
            work_structs = sc.objdict()
            work_structs.employment_rates = employment_rates
            work_structs.workers_by_age_to_assign_count = workers_by_age_to_assign_count
            work_structs.potential_worker_uids = potential_worker_uids
            work_structs.potential_worker_uids_by_age = potential_worker_uids_by_age
            work_structs.potential_worker_ages_left_count = potential_worker_ages_left_count
            self.work_structs = work_structs

        # remove facilities from homes --- have already assigned each person a uid
        homes_by_uids = homes_by_uids[len(facilities_by_uid_lists):]
        homes = homes[len(facilities_by_uid_lists):]

        # update your school mixing types
        school_mixing_types = self.get_school_mixing_types(pars.school_mixing_type, school_type_by_age)

        # Consolidate the structural assignments. 
        structs = sc.objdict()
        structs.age_by_uid = age_by_uid
        if self.input_pars.init_incomes_and_watches:
            structs.fam_income_by_uid = fam_income_by_uid
        structs.homes_by_uids = homes_by_uids
        structs.homes_by_ages = homes
        structs.student_uid_lists = student_uid_lists
        structs.student_age_lists = student_age_lists
        structs.school_type_by_age = school_type_by_age
        structs.school_mixing_types = school_mixing_types
        structs.school_types = school_types

        if distribute_workers:
            structs.teacher_uid_lists = teacher_uid_lists
            structs.non_teaching_staff_uid_lists = non_teaching_staff_uid_lists
            structs.workplace_uid_lists = workplace_uid_lists
            structs.facilities_staff_uid_lists = facilities_staff_uid_lists

        self.structs = structs


    def generate(self):
        """
        Actually generate the network.

        Returns:
            network (dict): A dictionary of the full population with ages, connections, and other attributes.
        """

        self.load_pars_and_data() # Updates self.pars

        self.make_structures() # Updates self.structs

        # zncnx.make_all_contacts(self, self.structs, self.pars) # Updates self.popdict
        self.make_all_contacts()

        # This needs to be placed here because additional structure (classroom-resolution for schools) is introduced in make_contacts. 
        self.consolidate_structures(self.structs)

        # Change types
        for key, person in self.popdict.items():
            for layerkey in self.popdict[key]['contacts'].keys():
                self.popdict[key]['contacts'][layerkey] = list(self.popdict[key]['contacts'][layerkey])

    def set_layer_classes(self):
        """Add layer classes."""
        self.initialize_households_list()
        self.populate_households(self.homes_by_uids, self.age_by_uid)
        self.initialize_workplaces_list()
        self.populate_workplaces(self.workplace_uid_lists)

        self.initialize_schools_list()
        self.populate_schools(self.student_uid_lists, self.teacher_uid_lists,
                              self.non_teaching_staff_uid_lists, self.age_by_uid,
                              self.school_types, self.school_mixing_types)

        self.populate_all_classrooms(self.schools_in_groups)

        return

    def clean_up_layer_info(self):
        """
        Clean up temporary data from the pop object after storing them in specific layer classes.
        """
        for key in ['workplace_uid_lists', 'student_uid_lists', 'teacher_uid_lists',
                    'non_teaching_staff_uid_lists', 'school_types',
                    'school_mixing_types', 'schools_in_groups',
                    ]:
            self.pop_item(key)
        return

    def pop_item(self, key):
        """Pop key from self."""
        self.__dict__.pop(key, None)  # pop checks if the key exists as an attribute and removes it in that case. Returns a default value of None if the key does not exist

    def to_dict(self):
        """
        Export to a dictionary -- official way to get the popdict.

        **Example**::

            popdict = pop.to_dict()
        """
        return sc.dcp(self.popdict)

    def to_json(self, filename, indent=2, **kwargs):
        """
        Export to a JSON file.

        **Example**::

            pop.to_json('my-pop.json')
        """
        return sc.savejson(filename, self.popdict, indent=indent, **kwargs)

    def save(self, filename, **kwargs):
        """
        Save population to an binary, gzipped object file.

        **Example**::

            pop.save('my-pop.pop')
        """
        return sc.saveobj(filename, self, **kwargs)

    @staticmethod
    def load(filename, *args, **kwargs):
        """
        Load from disk from a gzipped pickle.

        Args:
            filename (str): the name or path of the file to load from
            kwargs: passed to sc.loadobj()

        **Example**::

            pop = sp.Pop.load('my-pop.pop')
        """
        pop = sc.loadobj(filename, *args, **kwargs)
        if not isinstance(pop, BehaviourModel):
            errormsg = f'Cannot load object of {type(pop)} as a Pop object'
            raise TypeError(errormsg)
        return pop

    def initialize_households_list(self):
        """Initialize a new households list."""
        self.households = []
        return

    def initialize_empty_households(self, n_households=None):
        """
        Create a list of empty households.

        Args:
            n_households (int) : the number of households to initialize
        """
        znhh.initialize_empty_households(self, n_households)
        return

    def populate_households(self, households, age_by_uid):
        """
        Populate all of the households. Store each household at the index corresponding to it's hhid.

        Args:
            households (list) : list of lists where each sublist represents a household and contains the ids of the household members
            age_by_uid (dict) : dictionary mapping each person's id to their age
        """
        znhh.populate_households(self, households, age_by_uid)
        return

    def get_household(self, hhid):
        """
        Return household with id: hhid.

        Args:
            hhid (int) : household id number

        Returns:
            sp.Household: A populated household.
        """
        return znhh.get_household(self, hhid)

    def add_household(self, household):
        """
        Add a household to the list of households.

        Args:
            household (sp.Household): household with at minimum the hhid, member_uids, member_ages, reference_uid, and reference_age.
        """
        znhh.add_household(self, household)
        return

    def initialize_workplaces_list(self):
        """Initialize a new workplaces list."""
        self.workplaces = []
        return

    def initialize_empty_workplaces(self, n_workplaces=None):
        """
        Create a list of empty workplaces.

        Args:
            n_households (int) : the number of workplaces to initialize
        """
        znhh.initialize_empty_workplaces(self, n_workplaces)
        return

    def populate_workplaces(self, workplaces):
        """
        Populate all of the workplaces. Store each workplace at the index corresponding to it's wpid.

        Args:
            workplaces (list) : list of lists where each sublist represents a workplace and contains the ids of the workplace members
            age_by_uid (dict) : dictionary mapping each person's id to their age
        """
        znwp.populate_workplaces(self, workplaces)
        return

    def get_workplace(self, wpid):
        """
        Return workplace with id: wpid.

        Args:
            wpid (int) : workplace id number

        Returns:
            sp.Workplace: A populated workplace.
        """
        return znwp.get_workplace(self, wpid)

    def add_workplace(self, workplace):
        """
        Add a workplace to the list of workplaces.

        Args:
            workplace (sp.Workplace): workplace with at minimum the wpid, member_uids, member_ages, reference_uid, and reference_age.
        """
        znwp.add_workplace(self, workplace)
        return

    def initialize_ltcfs_list(self):
        """Initialize a new ltcfs list."""
        self.ltcfs = []
        return

    def initialize_schools_list(self):
        """Initialize a new schools list."""
        self.schools = []
        return

    def initialize_empty_schools(self, n_schools=None):
        """
        Create a list of empty schools.

        Args:
            n_schools (int) : the number of schools to initialize
        """
        znsch.initialize_empty_schools(self, n_schools)
        return

    def populate_schools(self, student_lists, teacher_lists, non_teaching_staff_lists, age_by_uid, school_types=None, school_mixing_types=None):
        """
        Populate all of the schools. Store each school at the index corresponding to it's scid.

        Args:
            student_lists (list)            : list of lists where each sublist represents a school and contains the ids of the students
            teacher_lists (list)            : list of lists where each sublist represents a school and contains the ids of the teachers
            non_teaching_staff_lists (list) : list of lists where each sublist represents a school and contains the ids of the non teaching staff
            age_by_uid (dict)               : dictionary mapping each person's id to their age
            school_types (list)             : list of the school types
            school_mixing_types (list)      : list of the school mixing types
        """
        znsch.populate_schools(self, student_lists, teacher_lists, non_teaching_staff_lists, age_by_uid, school_types, school_mixing_types)
        return

    def get_school(self, scid):
        """
        Return school with id: scid.

        Args:
            scid (int) : school id number

        Returns:
            sp.School: A populated school.
        """
        return znsch.get_school(self, scid)

    def add_school(self, school):
        """
        Add a school to the list of schools.

        Args:
            school (sp.School): school
        """
        znsch.add_school(self, school)
        return

    def populate_all_classrooms(self, schools_in_groups):
        """
        Populate all of the classrooms in schools for each school that has
        school_mixing_type equal to 'age_and_class_clustered'. Each classroom
        will be indexed at id clid.

        Args:
            schools_in_groups (dict) : a dictionary representing each school in terms of student_groups and teacher_groups corresponding to classrooms
        """
        for ns in range(self.n_schools):
            znsch.initialize_empty_classrooms(self.schools[ns], len(schools_in_groups[ns]['student_groups']))
            znsch.populate_classrooms(self.schools[ns], schools_in_groups[ns]['student_groups'], schools_in_groups[ns]['teacher_groups'], self.age_by_uid)
        return

    def get_classroom(self, scid, clid):
        """
        Return classroom with id: clid from school with id: scid.

        Args:
            scid (int) : school id number
            clid (int) : classroom id number

        Returns:
            sp.Classroom : A populated classroom.
        """
        return znsch.get_classroom(self, scid, clid)

    def compute_information(self):
        """Computing an advanced description of the population."""
        self.information = sc.objdict()
        self.information.age_count = self.count_pop_ages()
        self.information.layer_degrees = dict()
        self.information.layer_stats = dict()
        self.information.layer_degree_description = dict()

        for layer in self.layers:
            self.information.layer_degrees[layer] = zncnx.count_layer_degree(self, layer=layer)
            self.information.layer_stats[layer] = self.information.layer_degrees[layer].describe()[['age', 'degree']]
            self.information.layer_degree_description[layer] = self.information.layer_degrees[layer].groupby('age')['degree'].describe(percentiles=[0.05, 0.25, 0.5, 0.75, 0.95])  # default percentiles to include

        self.information.household_sizes = self.get_household_sizes()
        self.information.household_size_count = self.count_household_sizes()

        self.information.household_heads = self.get_household_heads()
        self.information.household_head_ages = self.get_household_head_ages()
        self.information.household_head_age_count = self.count_household_head_ages()
        self.information.household_head_ages_by_size_count = self.get_household_head_ages_by_size()

        self.information.ltcf_sizes = self.get_ltcf_sizes()
        self.information.ltcf_size_count = self.count_ltcf_sizes()

        self.information.enrollment_by_age = self.count_enrollment_by_age()
        self.information.enrollment_by_school_type = self.count_enrollment_by_school_type()

        self.information.employment_by_age = self.count_employment_by_age()
        self.information.workplace_sizes = self.get_workplace_sizes()
        self.information.workplace_size_count = self.count_workplace_sizes()

        return

    def compute_summary(self):
        """Compute summaries and add to pop post generation."""
        self.summary = sc.objdict()
        self.summary.mean_age = znb.calculate_mean_from_count(self.information.age_count)
        self.summary.std_age = znb.calculate_std_from_count(self.information.age_count)

        self.summary.layers = dict()
        for layer in self.layers:
            self.summary.layers[layer] = dict()

        percentiles = [5, 95]

        self.summary.layers['H']['mean'] = np.mean(list(self.information.household_sizes.values()))
        self.summary.layers['H']['std'] = np.std(list(self.information.household_sizes.values()))
        for p in percentiles:
            self.summary.layers['H'][p] = np.percentile(list(self.information.household_sizes.values()), q=p)

        sizes = []
        for s in self.information.enrollment_by_school_type.keys():
            sizes.extend(self.information.enrollment_by_school_type[s])
        self.summary.layers['S']['mean'] = np.mean(sizes)
        self.summary.layers['S']['std'] = np.std(sizes)
        for p in percentiles:
            self.summary.layers['S'][p] = np.percentile(sizes, q=p)

        self.summary.layers['W']['mean'] = np.mean(list(self.information.workplace_sizes.values()))
        self.summary.layers['W']['std'] = np.std(list(self.information.workplace_sizes.values()))
        for p in percentiles:
            self.summary.layers['W'][p] = np.percentile(list(self.information.workplace_sizes.values()), q=p)

    def summarize(self, return_msg=False):
        """Print and optionally return a brief summary string of the pop."""
        msg = ""
        msg += f"This networked population is created to resemble the population of {self.location + ',' if self.location is not None else ''} {self.state_location + ',' if self.state_location is not None else ''} {self.country_location if self.country_location is not None else ''}.\n"
        msg += f"The number of people is {self.n:.0f}.\n"
        msg += f"The mean age is {self.summary.mean_age:.2f} +/- {self.summary.std_age:.2f} years old.\n"
        msg += "\n"

        for layer in self.layers:
            s = self.information.layer_stats[layer]

            msg += f"Layer {layer}: {self.layer_mappings[layer]}\n"
            msg += f"   Number of people: {len(self.information.layer_degrees[layer]):.0f}\n"
            msg += f"   Number of edges: {self.n * s.loc[s.index == 'mean']['degree'][0] * 2:.0f} ({s.loc[s.index == 'mean']['degree'][0]:.1f} ± {s.loc[s.index == 'std']['degree'][0]:.1f} per person)\n"
            msg += f"   Age (years): {s.loc[s.index == 'mean']['age'][0]:.1f} ({s.loc[s.index == 'min']['age'][0]:.0f}-{s.loc[s.index == 'max']['age'][0]:.0f})\n"

            if layer in ['H', 'S', 'W']:
                msg += f"   {self.layer_mappings[layer].title()} size: {self.summary.layers[layer]['mean']:.1f} ± {self.summary.layers[layer]['std']:.1f} people (range is {self.summary.layers[layer][5]:.1f}-{self.summary.layers[layer][95]:.1f}).\n"

            msg += "\n"

        msg += f"The rand_seed used to generate this population is {self.rand_seed}."

        print(msg)
        if return_msg:
            return msg
        else:
            return

    def count_pop_ages(self):
        """
        Create an age count of the generated population post generation.

        Returns:
            dict: Dictionary of the age count of the generated population.
        """
        return znb.count_ages(self.popdict)

    # convert to work on array
    def get_household_sizes(self):
        """
        Create household sizes in the generated population post generation.

        Returns:
            dict: Dictionary of household size by household id (hhid).
        """
        return znhh.get_household_sizes(self.popdict)

    # convert to work on array
    def count_household_sizes(self):
        """
        Count of household sizes in the generated population.

        Returns:
            dict: Dictionary of the count of household sizes.
        """
        return znb.count_values(self.information.household_sizes)

    # convert to work on array
    def get_household_heads(self):
        """Get the ids of the head of households in the generated population post generation."""
        return znhh.get_household_heads(self.popdict)

    def get_household_head_ages(self):
        """Get the age of the head of each household in the generated population post generation."""
        return {hhid: self.popdict[head_id]['age'] for hhid, head_id in self.information.household_heads.items()}

    def count_household_head_ages(self, bins=None):
        """
        Count of household head ages in the generated population.

        Args:
            bins (array) : If supplied, use this to create a binned count of the household head ages. Otherwise, count discrete household head ages.

        Returns:
            dict: Dictionary of the count of household head ages.
        """
        if bins is None:
            return znb.count_values(self.information.household_head_ages)
        else:
            head_ages = list(self.information.household_head_ages.values())
            hist, bins = np.histogram(head_ages, bins=bins, density=0)
            return {i: hist[i] for i in range(len(hist))}

    def get_household_head_ages_by_size(self):
        """
        Get the count of households by size and the age of the head of the
        household, assuming the minimal household members id is the id of the
        head of the household.

        Returns:
            np.ndarray: An array with row as household size and columns as
            household head age brackets.
        """
        return znhh.get_household_head_ages_by_size(self)


    def count_enrollment_by_age(self):
        """
        Create enrollment count by age for students in the generated population post generation.

        Returns:
            dict: Dictionary of the count of enrolled students by age in the generated population.
        """
        return znsch.count_enrollment_by_age(self.popdict)

    @property
    def enrollment_rates_by_age(self):
        """
        Enrollment rates by age for students in the generated population.

        Returns:
            dict: Dictionary of the enrollment rates by age for students in the generated population.
        """
        return {k: self.information.enrollment_by_age[k]/self.information.age_count[k] if self.information.age_count[k] > 0 else 0 for k in range(defaults.settings.max_age)}

    def count_enrollment_by_school_type(self, *args, **kwargs):
        """
        Create enrollment sizes by school types in the generated population post generation.

        Returns:
            list: List of generated enrollment sizes by school type.
        """
        enrollment_by_school_type = znsch.count_enrollment_by_school_type(self.popdict, *args, **kwargs)
        return enrollment_by_school_type

    def count_employment_by_age(self):
        """
        Create employment count by age for workers in the generated population post generation.

        Returns:
            dict: Dictionary of the count of employed workers by age in the generated population.
        """
        return znwp.count_employment_by_age(self.popdict)

    @property
    def employment_rates_by_age(self):
        """
        Employment rates by age for workers in the generated population.

        Returns:
            dict: Dictionary of the employment rates by age for workers in the generated population.
        """
        return {k: self.information.employment_by_age[k]/self.information.age_count[k] if self.information.age_count[k] > 0 else 0 for k in range(defaults.settings.max_age)}

    # convert to work on array
    def get_workplace_sizes(self):
        """
        Create workplace sizes in the generated population post generation.

        Returns:
            dict: Dictionary of workplace size by workplace id (wpid).
        """
        return znwp.get_workplace_sizes(self.popdict)

    # convert to work on array
    def count_workplace_sizes(self):
        """
        Count of workplace sizes in the generated population.

        Returns:
            dict:Dictionary of the count of workplace sizes.
        """
        return znb.count_values(self.information.workplace_sizes)

    def get_contact_counts_by_layer(self, layer='S', **kwargs):
        """
        Get the number of contacts by layer.

        Returns:
            dict: Dictionary of the count of contacts in the layer for the
            different people types in the layer. See
            sp.contact_networks.get_contact_counts_by_layer() for method details.
        """
        return zncnx.get_contact_counts_by_layer(self.popdict, layer, **kwargs)

    def to_people(self):
        ''' Convert to the alternative People representation of a population '''
        ppl = spp.make_people(popdict=self.popdict, rand_seed=self.rand_seed)  # Create the corresponding population
        return ppl
